import 'dart:async'; // ADDED for StreamSubscription
import 'dart:convert'; // ADDED for utf8
import 'dart:io'; // ENSURE plain import
import 'dart:ui' as ui; // ADDED for ui.Image
// import 'package:billfie/models/bill_image.dart'; // REMOVED
import 'package:billfie/screens/receipt_upload_screen.dart';
import 'package:billfie/services/file_helper.dart';
import 'package:billfie/widgets/receipt_upload/full_image_viewer.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/foundation.dart'; // For kIsWeb, though not strictly needed for these fakes
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker/image_picker.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

// Generate mocks for ImagePicker and File
@GenerateMocks([ImagePicker, File]) // ENSURE unprefixed File
import 'receipt_upload_screen_test.mocks.dart'; // This file will be generated by build_runner

// Minimal transparent PNG bytes
const List<int> kTransparentImageBytes = <int>[
  0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A,0x00,0x00,0x00,0x0D,0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x08,0x06,0x00,0x00,0x00,0x1F,0x15,0xC4,0x89,0x00,0x00,0x00,0x0A,0x49,0x44,0x41,0x54,0x78,0x9C,0x63,0x00,0x01,0x00,0x00,0x05,0x00,0x01,0x0D,0x0A,0x2D,0xB4,0x00,0x00,0x00,0x00,0x49,0x45,0x4E,0x44,0xAE,0x42,0x60,0x82,
];

// --- Minimal Fake HTTP Client for CachedNetworkImage testing ---
class FakeHttpHeaders implements HttpHeaders { // REVERTED: Unprefixed
  final Map<String, List<String>> _headers = {};
  final String _defaultReasonPhrase = 'OK'; // Default reason phrase

  @override
  List<String>? operator [](String name) => _headers[name.toLowerCase()];
  @override
  void add(String name, Object value, {bool preserveHeaderCase = false}) {
    _headers.putIfAbsent(name.toLowerCase(), () => []).add(value.toString());
  }
  @override
  void set(String name, Object value, {bool preserveHeaderCase = false}) {
    _headers[name.toLowerCase()] = [value.toString()];
  }
  @override
  String? value(String name) => _headers[name.toLowerCase()]?.first;
  @override
  void clear() => _headers.clear();
  @override
  void forEach(void Function(String name, List<String> values) f) => _headers.forEach(f);
  @override
  void noFolding(String name) {}
  @override
  void remove(String name, Object value) => _headers[name.toLowerCase()]?.remove(value.toString());
  @override
  void removeAll(String name) => _headers.remove(name.toLowerCase());
  
  // Properties (with defaults or nulls)
  bool _chunkedTransferEncoding = false;
  @override
  bool get chunkedTransferEncoding => _chunkedTransferEncoding;
  @override
  set chunkedTransferEncoding(bool value) => _chunkedTransferEncoding = value;

  int _contentLength = -1;
  @override
  int get contentLength => _contentLength;
  @override
  set contentLength(int value) => _contentLength = value;

  DateTime? _date;
  @override
  DateTime? get date => _date;
  @override
  set date(DateTime? value) => _date = value;

  DateTime? _expires;
  @override
  DateTime? get expires => _expires;
  @override
  set expires(DateTime? value) => _expires = value;

  String? _host;
  @override
  String? get host => _host;
  @override
  set host(String? value) => _host = value;

  DateTime? _ifModifiedSince;
  @override
  DateTime? get ifModifiedSince => _ifModifiedSince;
  @override
  set ifModifiedSince(DateTime? value) => _ifModifiedSince = value;

  bool _persistentConnection = true;
  @override
  bool get persistentConnection => _persistentConnection;
  @override
  set persistentConnection(bool value) => _persistentConnection = value;

  int? _port;
  @override
  int? get port => _port;
  @override
  set port(int? value) => _port = value;

  ContentType? _contentType; // REVERTED: Unprefixed
  @override
  ContentType? get contentType => _contentType; // REVERTED: Unprefixed
  @override
  set contentType(ContentType? value) => _contentType = value; // REVERTED: Unprefixed

  @override
  String toString() => 'FakeHttpHeaders($_headers)';
}

class FakeHttpClientResponse extends Stream<List<int>> implements HttpClientResponse { // REVERTED: Unprefixed
  final List<int> _bytes;
  FakeHttpClientResponse(this._bytes);

  @override
  int get statusCode => 200;
  @override
  HttpHeaders get headers => FakeHttpHeaders(); // REVERTED: Unprefixed
  @override
  int get contentLength => _bytes.length;
  @override
  bool get isRedirect => false;
  @override
  List<RedirectInfo> get redirects => []; // REVERTED: Unprefixed
  @override
  String get reasonPhrase => 'OK';
  @override
  StreamSubscription<List<int>> listen(void Function(List<int> event)? onData, {Function? onError, void Function()? onDone, bool? cancelOnError}) {
    return Stream.fromIterable([_bytes]).listen(onData, onError: onError, onDone: onDone, cancelOnError: cancelOnError);
  }
  // Other properties and methods with default/null/throwing implementations
  @override
  X509Certificate? get certificate => null; // REVERTED: Unprefixed
  @override
  HttpConnectionInfo? get connectionInfo => null; // REVERTED: Unprefixed
  @override
  List<Cookie> get cookies => []; // REVERTED: Unprefixed
  @override
  Future<Socket> detachSocket() => throw UnimplementedError('detachSocket'); // REVERTED: Unprefixed
  @override
  bool get persistentConnection => true;
  @override
  Future<HttpClientResponse> redirect([String? method, Uri? url, bool? followLoops]) => throw UnimplementedError('redirect');
  @override
  HttpClientResponseCompressionState get compressionState => HttpClientResponseCompressionState.notCompressed; // MODIFIED: Use HttpClientResponseCompressionState
}

class FakeHttpClientRequest implements HttpClientRequest { // REVERTED: Unprefixed
  FakeHttpClientRequest(this.url);
  final Uri url;
  final HttpHeaders _headers = FakeHttpHeaders(); // REVERTED: Unprefixed
  List<List<int>> _addedData = [];

  @override
  HttpHeaders get headers => _headers; // REVERTED: Unprefixed
  @override
  Future<HttpClientResponse> close() async => FakeHttpClientResponse(kTransparentImageBytes); // REVERTED: Unprefixed
  
  @override
  void add(List<int> data) => _addedData.add(data);
  @override
  void addError(Object error, [StackTrace? stackTrace]) {} // No-op
  @override
  Future addStream(Stream<List<int>> stream) async {
    await for (var data in stream) {
      _addedData.add(data);
    }
  }
  @override
  void write(Object? obj) => add(utf8.encode(obj.toString()));
  @override
  void writeAll(Iterable objects, [String separator = ""] ) => write(objects.join(separator));
  @override
  void writeCharCode(int charCode) => add([charCode]);
  @override
  void writeln([Object? obj = ""] ) => write('${obj.toString()}\n');
  
  // Other properties and methods with default/null/throwing implementations
  @override
  Encoding encoding = utf8;
  @override
  HttpConnectionInfo? get connectionInfo => null; // REVERTED: Unprefixed
  @override
  List<Cookie> get cookies => []; // REVERTED: Unprefixed
  @override
  Future<HttpClientResponse> get done async => close(); // REVERTED: Unprefixed
  @override
  String get method => 'GET'; // Default
  @override
  Uri get uri => url;

  bool _followRedirects = true;
  @override
  bool get followRedirects => _followRedirects;
  @override
  set followRedirects(bool value) => _followRedirects = value;

  int _maxRedirects = 5;
  @override
  int get maxRedirects => _maxRedirects;
  @override
  set maxRedirects(int value) => _maxRedirects = value;

  // Added missing persistentConnection from HttpClientRequest interface
  bool _persistentConnection = true;
  @override
  bool get persistentConnection => _persistentConnection;
  @override
  set persistentConnection(bool value) => _persistentConnection = value;

  // IOSink methods for HttpClientRequest
  @override
  Future flush() async {} // No-op
  @override
  void abort([Object? exception, StackTrace? stackTrace]) {} // No-op

  bool _bufferOutput = true; // Default
  @override
  bool get bufferOutput => _bufferOutput;
  @override
  set bufferOutput(bool value) => _bufferOutput = value;

  int _contentLength = 0; // Initialize to 0, actual calculation below
  @override
  int get contentLength => _addedData.fold(0, (sum, list) => sum + list.length);
  @override 
  set contentLength(int value) => _contentLength = value; // Can store if needed, or remain calculated by getter

  @override
  Future get doneRequest async => done; // from IOSink, maps to HttpClientRequest.done
}

class FakeHttpClient implements HttpClient { // REVERTED: Unprefixed
  @override
  Future<HttpClientRequest> getUrl(Uri url) async => FakeHttpClientRequest(url); // REVERTED: Unprefixed
  
  // Other methods with default/null/throwing or simplified implementations
  bool _autoUncompress = true;
  @override 
  bool get autoUncompress => _autoUncompress;
  @override 
  set autoUncompress(bool value) => _autoUncompress = value;

  Duration? _connectionTimeout;
  @override 
  Duration? get connectionTimeout => _connectionTimeout;
  @override 
  set connectionTimeout(Duration? value) => _connectionTimeout = value;

  Duration _idleTimeout = const Duration(seconds: 15);
  @override 
  Duration get idleTimeout => _idleTimeout;
  @override 
  set idleTimeout(Duration value) => _idleTimeout = value;

  int? _maxConnectionsPerHost;
  @override 
  int? get maxConnectionsPerHost => _maxConnectionsPerHost;
  @override 
  set maxConnectionsPerHost(int? value) => _maxConnectionsPerHost = value;

  String? _userAgent;
  @override 
  String? get userAgent => _userAgent;
  @override 
  set userAgent(String? value) => _userAgent = value;

  @override void addCredentials(Uri url, String realm, HttpClientCredentials credentials) {} // REVERTED: Unprefixed
  @override void addProxyCredentials(String host, int port, String realm, HttpClientCredentials credentials) {} // REVERTED: Unprefixed
  @override set authenticate(Future<bool> Function(Uri url, String scheme, String? realm)? f) {}
  @override set authenticateProxy(Future<bool> Function(String host, int port, String scheme, String? realm)? f) {}
  @override set badCertificateCallback(bool Function(X509Certificate cert, String host, int port)? callback) {} // REVERTED: Unprefixed
  @override void close({bool force = false}) {}
  @override Future<HttpClientRequest> delete(String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> deleteUrl(Uri url) => getUrl(url); // REVERTED: Unprefixed
  @override set findProxy(String Function(Uri url)? f) {}
  @override Future<HttpClientRequest> get(String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> head(String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> headUrl(Uri url) => getUrl(url); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> open(String method, String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> openUrl(String method, Uri url) => getUrl(url); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> patch(String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> patchUrl(Uri url) => getUrl(url); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> post(String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> postUrl(Uri url) => getUrl(url); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> put(String host, int port, String path) => getUrl(Uri.http('$host:$port', path)); // REVERTED: Unprefixed
  @override Future<HttpClientRequest> putUrl(Uri url) => getUrl(url); // REVERTED: Unprefixed

  // Added missing setters from HttpClient interface
  @override
  set connectionFactory(Future<ConnectionTask<Socket>> Function(Uri url, String? proxyHost, int? proxyPort)? f) {} // REVERTED: Unprefixed
  @override
  set keyLog(void Function(String line)? callback) {}
}
// --- End Fake HTTP Client ---

// Helper function to create a minimal ui.Image for testing CachedNetworkImage
// REMOVED _createMinimalUiImage as HttpOverrides is used now.
// Future<ui.Image> _createMinimalUiImage() async { ... }

void main() {
  late MockImagePicker mockImagePicker;
  late MockFile mockImageFile; // Still useful if we need to mock File methods directly for other reasons later
  // late MockFileHelper mockFileHelper; // REMOVED
  late XFile testXFile;
  late Directory tempDir; // REVERTED: Unprefixed

  setUp(() {
    mockImagePicker = MockImagePicker();
    mockImageFile = MockFile();
    // mockFileHelper = MockFileHelper(); // REMOVED
    
    tempDir = Directory.systemTemp.createTempSync('receipt_upload_test_'); // REVERTED: Unprefixed
    final tempFilePath = '${tempDir.path}/test_image.jpg';
    final tempFile = File(tempFilePath); // REVERTED: Unprefixed
    tempFile.createSync(recursive: true); 
    tempFile.writeAsStringSync('dummy content'); // Ensure file is not empty
    testXFile = XFile(tempFilePath);

    when(mockImageFile.path).thenReturn(testXFile.path);
    // No FileHelper stubbing needed here anymore
  });

  tearDown(() {
    // Clean up temp directory
    if (tempDir.existsSync()) {
      tempDir.deleteSync(recursive: true);
    }
  });


  // Helper function to pump the widget
  Widget _boilerplate({
    File? imageFile, // REVERTED: Unprefixed
    String? imageUrl,
    String? loadedThumbnailUrl,
    bool isLoading = false,
    bool isSuccessfullyParsed = false,
    required Function(File?) onImageSelected, // REVERTED: Unprefixed
    required Function() onParseReceipt,
    required Function() onRetry,
  }) {
    return MaterialApp(
      home: Scaffold(
        body: ReceiptUploadScreen(
          imageFile: imageFile,
          imageUrl: imageUrl,
          loadedThumbnailUrl: loadedThumbnailUrl,
          isLoading: isLoading,
          isSuccessfullyParsed: isSuccessfullyParsed,
          onImageSelected: onImageSelected,
          onParseReceipt: onParseReceipt,
          onRetry: onRetry,
          picker: mockImagePicker,
        ),
      ),
    );
  }

  group('ReceiptUploadScreen Tests', () {
    group('Initial State (No Image)', () {
      testWidgets('displays placeholder, Gallery and Camera buttons', (WidgetTester tester) async {
        File? selectedFile; // REVERTED: Unprefixed
        await tester.pumpWidget(_boilerplate(
          onImageSelected: (file) => selectedFile = file,
          onParseReceipt: () {},
          onRetry: () {},
        ));

        expect(find.byIcon(Icons.receipt_long_outlined), findsOneWidget);
        expect(find.byKey(const ValueKey('upload_placeholder_text')), findsOneWidget);
        expect(find.byKey(const ValueKey('gallery_button')), findsOneWidget);
        expect(find.byKey(const ValueKey('camera_button')), findsOneWidget);
      });

      testWidgets('tapping "Gallery" button calls pickImage and onImageSelected', (WidgetTester tester) async {
        File? selectedFile; // REVERTED: Unprefixed
        when(mockImagePicker.pickImage(source: ImageSource.gallery, imageQuality: 90))
            .thenAnswer((_) async => testXFile);
        
        // It's important that mockImageFile.path is stubbed correctly before this.
        // And FileHelper.isValidImageFile(any) should return true.

        await tester.pumpWidget(_boilerplate(
          onImageSelected: (file) {
            selectedFile = file;
          },
          onParseReceipt: () {},
          onRetry: () {},
        ));

        await tester.tap(find.byKey(const ValueKey('gallery_button')));
        await tester.pumpAndSettle(); // Allow image picking and initial validation
        await tester.pump(const Duration(seconds: 2)); // Wait for potential toast
        await tester.pumpAndSettle(); // Settle any remaining timers

        verify(mockImagePicker.pickImage(source: ImageSource.gallery, imageQuality: 90)).called(1);
        expect(selectedFile, isNotNull);
        expect(selectedFile?.path, testXFile.path);
      });

      testWidgets('tapping "Camera" button calls pickImage (camera) and onImageSelected', (WidgetTester tester) async {
        File? selectedFile; // REVERTED: Unprefixed
        when(mockImagePicker.pickImage(source: ImageSource.camera, imageQuality: 90, preferredCameraDevice: CameraDevice.rear))
            .thenAnswer((_) async => testXFile);

        await tester.pumpWidget(_boilerplate(
          onImageSelected: (file) => selectedFile = file,
          onParseReceipt: () {},
          onRetry: () {},
        ));

        await tester.tap(find.byKey(const ValueKey('camera_button')));
        await tester.pumpAndSettle(); // Allow image picking and initial validation
        await tester.pump(const Duration(seconds: 2)); // Wait for potential toast
        await tester.pumpAndSettle(); // Settle any remaining timers

        verify(mockImagePicker.pickImage(source: ImageSource.camera, imageQuality: 90, preferredCameraDevice: CameraDevice.rear)).called(1);
        expect(selectedFile, isNotNull);
        expect(selectedFile?.path, testXFile.path);
      });
    });

    group('Local Image Displayed', () {
      setUp(() {
        // Ensure mockImageFile is ready for these tests
        // The path is already stubbed in the main setUp
      });

      testWidgets('displays Image.file, Retry and Use This buttons', (WidgetTester tester) async {
        // Use the real file path from testXFile for consistency
        final displayFile = File(testXFile.path); // REVERTED: Unprefixed

        await tester.pumpWidget(_boilerplate(
          imageFile: displayFile,
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () {},
        ));

        // Check for Image.file - it's tricky to directly check type due to internal widgets.
        // Instead, look for a Hero widget whose child is a Material > InkWell > actual Image
        // and verify its properties, or find an ancestor of the image that's unique.
        // For now, a general Image find might pass if it's the only one.
        expect(find.byType(Image), findsOneWidget);
        // A more robust way if Image.file is used:
        final imageWidget = tester.widget<Image>(find.byType(Image));
        expect(imageWidget.image, isA<FileImage>());
        expect((imageWidget.image as FileImage).file.path, displayFile.path);


        expect(find.byKey(const ValueKey('retry_button')), findsOneWidget);
        expect(find.byKey(const ValueKey('use_this_button')), findsOneWidget);
      });

      testWidgets('tapping "Retry" button calls onRetry', (WidgetTester tester) async {
        bool retryCalled = false;
        final displayFile = File(testXFile.path); // REVERTED: Unprefixed

        await tester.pumpWidget(_boilerplate(
          imageFile: displayFile,
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () => retryCalled = true,
        ));

        await tester.ensureVisible(find.byKey(const ValueKey('retry_button'))); // ADDED: Ensure button is visible
        await tester.tap(find.byKey(const ValueKey('retry_button')));
        await tester.pumpAndSettle(); // ADDED to ensure callback processing and UI update
        expect(retryCalled, isTrue);
      });

      testWidgets('tapping "Use This" button calls onParseReceipt', (WidgetTester tester) async {
        bool parseCalled = false;
        final displayFile = File(testXFile.path); // REVERTED: Unprefixed

        await tester.pumpWidget(_boilerplate(
          imageFile: displayFile,
          onImageSelected: (_) {},
          onParseReceipt: () => parseCalled = true,
          onRetry: () {},
        ));

        await tester.ensureVisible(find.byKey(const ValueKey('use_this_button'))); // ADDED: Ensure button is visible
        await tester.tap(find.byKey(const ValueKey('use_this_button')));
        await tester.pumpAndSettle(); // ADDED to ensure callback processing and UI update
        expect(parseCalled, isTrue);
      });

      // Test for tapping image and showing FullImageViewer
      testWidgets('tapping local image shows FullImageViewer via dialog', (WidgetTester tester) async {
        final displayFile = File(testXFile.path); // REVERTED: Unprefixed
        
        await tester.pumpWidget(_boilerplate(
          imageFile: displayFile,
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () {},
        ));

        // The image is wrapped in InkWell inside Hero -> Material
        final imageInteractionWidget = find.byKey(const ValueKey('image_preview_inkwell'));
        expect(imageInteractionWidget, findsOneWidget);
        
        await tester.tap(imageInteractionWidget);
        await tester.pump(const Duration(milliseconds: 500)); // MODIFIED: Give more time for animations

        // Verify FullImageViewer is shown (it's pushed as a dialog)
        // We can check for a widget type unique to FullImageViewer or its content
        // For simplicity, let's assume FullImageViewer itself is identifiable
        // If showFullImageDialog pushes a specific dialog route, we can also check for that.
        expect(find.byType(FullImageViewer), findsOneWidget);
        // And verify the correct imageFile was passed to FullImageViewer
        final fullImageViewer = tester.widget<FullImageViewer>(find.byType(FullImageViewer));
        expect(fullImageViewer.imageFile?.path, displayFile.path);

        // Close the dialog
        Navigator.of(tester.element(find.byType(FullImageViewer))).pop();
        await tester.pump(const Duration(milliseconds: 500)); // MODIFIED: from pumpAndSettle() to allow dismissal animation
      });
    });

    group('Network Image Displayed', () {
      const testImageUrl = 'http://example.com/image.png';
      const testThumbnailUrl = 'http://example.com/thumbnail.png';

      testWidgets('displays CachedNetworkImage, Retry and Use This buttons (with main image URL)', (WidgetTester tester) async {
        await tester.pumpWidget(_boilerplate(
          imageUrl: testImageUrl,
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () {},
        ));
        
        // Verify CachedNetworkImage for the main image
        final mainImageFinder = find.byKey(const ValueKey('main_image_$testImageUrl'));
        expect(mainImageFinder, findsOneWidget);
        final cachedNetworkImageWidget = tester.widget<CachedNetworkImage>(mainImageFinder);
        expect(cachedNetworkImageWidget.imageUrl, testImageUrl);

        expect(find.byKey(const ValueKey('retry_button')), findsOneWidget);
        expect(find.byKey(const ValueKey('use_this_button')), findsOneWidget);
      });
      
      testWidgets('displays CachedNetworkImage (with thumbnail as placeholder)', (WidgetTester tester) async {
        await tester.pumpWidget(_boilerplate(
          imageUrl: testImageUrl, // Main image
          loadedThumbnailUrl: testThumbnailUrl, // Thumbnail available
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () {},
        ));
        await tester.pump(); // pump to let CachedNetworkImage build its placeholder

        // Main image should be there
        final mainImageFinder = find.byKey(const ValueKey('main_image_$testImageUrl'));
        expect(mainImageFinder, findsOneWidget);

        // Thumbnail should be used as a placeholder initially
        // The placeholder builder of the main CachedNetworkImage will render another CachedNetworkImage for the thumbnail
        final thumbnailAsPlaceholderFinder = find.byKey(const ValueKey('thumbnail_as_placeholder_${testThumbnailUrl}'));
        expect(thumbnailAsPlaceholderFinder, findsOneWidget);
        final thumbnailWidget = tester.widget<CachedNetworkImage>(thumbnailAsPlaceholderFinder);
        expect(thumbnailWidget.imageUrl, testThumbnailUrl);
        
        // REMOVED incorrect assertions for loading_indicator and loading_text from here
        // expect(find.byKey(const ValueKey('loading_indicator')), findsOneWidget); 
        // expect(find.byKey(const ValueKey('loading_text')), findsOneWidget); 
        
        // expect(find.byKey(const ValueKey('retry_button')), findsNothing); 
        // expect(find.byKey(const ValueKey('use_this_button')), findsNothing); 
      });


      testWidgets('tapping network image shows FullImageViewer with network URL', (WidgetTester tester) async {
        await HttpOverrides.runZoned(() async { // ENSURE HttpOverrides is unprefixed
          await tester.pumpWidget(_boilerplate(
            imageUrl: testImageUrl,
            onImageSelected: (_) {},
            onParseReceipt: () {},
            onRetry: () {},
          ));

          final imageInteractionWidget = find.ancestor(
              of: find.byKey(const ValueKey('main_image_$testImageUrl')),
              matching: find.byType(InkWell),
          );
          expect(imageInteractionWidget, findsOneWidget);

          await tester.tap(imageInteractionWidget);
          await tester.pump(const Duration(milliseconds: 500)); // MODIFIED: Give more time for animations

          expect(find.byType(FullImageViewer), findsOneWidget);

          Navigator.of(tester.element(find.byType(FullImageViewer))).pop();
          await tester.pump(const Duration(milliseconds: 500)); // MODIFIED: from pumpAndSettle() to allow dismissal animation
        }, createHttpClient: (_) => FakeHttpClient());
      });
    });
    
    group('Loading State', () {
      testWidgets('displays CircularProgressIndicator and "Processing Receipt..." text', (WidgetTester tester) async {
        final displayFile = File(testXFile.path); // REVERTED: Unprefixed
        await tester.pumpWidget(_boilerplate(
          imageFile: displayFile,
          isLoading: true,
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () {},
        ));

        expect(find.byType(CircularProgressIndicator), findsOneWidget);
        expect(find.text('Processing Receipt...'), findsOneWidget);
        
        // Buttons might be disabled or hidden, check specific behavior
        // "Retry" and "Use This" buttons are inside a Row that is conditionally rendered if !widget.isLoading
        expect(find.byKey(const ValueKey('retry_button')), findsNothing);
        expect(find.byKey(const ValueKey('use_this_button')), findsNothing);
      });
    });

    group('Successfully Parsed State', () {
      testWidgets('Retry button is disabled when isSuccessfullyParsed is true', (WidgetTester tester) async {
        final displayFile = File(testXFile.path); // REVERTED: Unprefixed
        await tester.pumpWidget(_boilerplate(
          imageFile: displayFile,
          isSuccessfullyParsed: true,
          onImageSelected: (_) {},
          onParseReceipt: () {},
          onRetry: () {}, // onRetry won't be called as button is disabled
        ));

        final retryButton = tester.widget<FilledButton>(find.byKey(const ValueKey('retry_button')));
        expect(retryButton.onPressed, isNull); // Disabled buttons have null onPressed

        // "Use This" button should still be enabled for potential re-parse
        final useThisButton = tester.widget<FilledButton>(find.byKey(const ValueKey('use_this_button')));
        expect(useThisButton.onPressed, isNotNull); 
      });
    });
    
    group('File Validation Logic', () {
      testWidgets('onImageSelected is not called if FileHelper.isValidImageFile returns false (Gallery - invalid extension)', (WidgetTester tester) async {
        File? selectedFile; // REVERTED: Unprefixed
        
        // Create an XFile pointing to a file with an invalid extension
        final invalidExtFilePath = '${tempDir.path}/test_image.txt';
        final invalidExtFile = File(invalidExtFilePath); // REVERTED: Unprefixed
        invalidExtFile.createSync();
        invalidExtFile.writeAsStringSync('content');
        final invalidXFile = XFile(invalidExtFilePath);

        when(mockImagePicker.pickImage(source: ImageSource.gallery, imageQuality: 90))
            .thenAnswer((_) async => invalidXFile); // Return the file with invalid extension
        
        await tester.pumpWidget(_boilerplate(
          onImageSelected: (file) {
            selectedFile = file; 
          },
          onParseReceipt: () {},
          onRetry: () {},
        ));

        await tester.tap(find.byKey(const ValueKey('gallery_button')));
        await tester.pumpAndSettle(); // Allow image picking and initial validation
        await tester.pump(const Duration(seconds: 2)); // Wait for toast to clear
        await tester.pumpAndSettle(); // Settle any remaining timers

        verify(mockImagePicker.pickImage(source: ImageSource.gallery, imageQuality: 90)).called(1);
        expect(selectedFile, isNull); 
        
        // Clean up the specific invalid file if needed, though tearDown should get the directory
        if (invalidExtFile.existsSync()) {
            invalidExtFile.deleteSync();
        }
      });

      testWidgets('onImageSelected is not called if FileHelper.isValidImageFile returns false (Camera - empty file)', (WidgetTester tester) async {
        File? selectedFile; // REVERTED: Unprefixed

        // Create an XFile pointing to an empty file (but with valid extension)
        final emptyFilePath = '${tempDir.path}/empty_test_image.jpg';
        final emptyFile = File(emptyFilePath); // REVERTED: Unprefixed
        emptyFile.createSync(); // Creates an empty file
        final emptyXFile = XFile(emptyFilePath);
        
        when(mockImagePicker.pickImage(source: ImageSource.camera, imageQuality: 90, preferredCameraDevice: CameraDevice.rear))
            .thenAnswer((_) async => emptyXFile); // Return the empty file
        
        await tester.pumpWidget(_boilerplate(
          onImageSelected: (file) {
            selectedFile = file; 
          },
          onParseReceipt: () {},
          onRetry: () {},
        ));

        await tester.tap(find.byKey(const ValueKey('camera_button')));
        await tester.pumpAndSettle(); // Allow image picking and initial validation
        await tester.pump(const Duration(seconds: 2)); // Wait for toast to clear
        await tester.pumpAndSettle(); // Settle any remaining timers

        verify(mockImagePicker.pickImage(source: ImageSource.camera, imageQuality: 90, preferredCameraDevice: CameraDevice.rear)).called(1);
        expect(selectedFile, isNull);
        
        if (emptyFile.existsSync()) {
            emptyFile.deleteSync();
        }
      });
    });

  });
}

// Helper to get the path of a mock file, needed if you directly use mockFile instances
// String? getMockFilePath(File? file) {
//   if (file is MockFile) {
//     // This requires your MockFile to have a 'path' getter if you are casting.
//     // Or, ensure your stubs for path are always set up.
//     return (file as MockFile).path; // This line can cause issues if not stubbed
//   }
//   return file?.path;
// }

// The @GenerateMocks annotation above will create 'receipt_upload_screen_test.mocks.dart'
// You need to run: flutter pub run build_runner build --delete-conflicting-outputs
// Make sure your pubspec.yaml has build_runner and mockito as dev_dependencies.
